varname='lambda'
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1){
proposal_sigs[[varname]]=1
}
}
}
current_values
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
varname='lambda'
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1){
proposal_sigs[[varname]]=1
}
}
}
varname
acceptance_rates[[varname]][jj]=0
update_var_generic
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun = likelihood_longitudinal,varname = varname)
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1){
proposal_sigs[[varname]]=1
}
}
}
varname
proposal_sigs
Nz=dim(Xdata$Xs)[1]
varname_list=c('lambda','beta_mat_f','beta_mat_b')
proposal_sigs=list('lambda'=.1,'beta_mat_f'=.1,'beta_mat_b'=.1)
sum_funs=list('lambda'=identity)
if(is.null(init_vals)){
init_vals=gen_initial_values_longitudinal(Xdata,Q)
}
current_values=init_vals
# M=configfile$M
store_iter=1
batch_size=1000
q_info=generate_q_info(Q)
acceptance_rates=lapply(varname_list,function(x) rep(NA,M))
names(acceptance_rates)=varname_list
update_sigma_tf=lapply(varname_list,function(x) FALSE)
names(update_sigma_tf)=varname_list
stored_parameters=list(current_values)
start_index=1
nsteps=1
for(jj in start_index:M)
{
if(jj%%10==0 & verb){
print(jj)
}
store=jj%%store_iter==0
storej=floor(jj/store_iter)
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1){
proposal_sigs[[varname]]=1
}
}
}
assign("proposal_sigs",proposal_sigs,envir = .GlobalEnv)
}
inputvals=current_values
transition_matrix=compute_transition_matrix(inputvals,Xdata,q_info)
mylogits=logit_probs_from_vals(inputvals,q_info)
Nz=dim(Xdata$Xs[[1]])[1]
transition_matrix=compute_transition_matrix(inputvals,Xdata,q_info)
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1){
proposal_sigs[[varname]]=1
}
}
}
proposal_sigs
current_values=mcmc_values
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1){
proposal_sigs[[varname]]=1
}
}
}
current_values$beta_mat_f
current_values$beta_mat_b
proposal_sigs
{
if(jj%%10==0 & verb){
print(jj)
}
store=jj%%store_iter==0
storej=floor(jj/store_iter)
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
}
assign("proposal_sigs",proposal_sigs,envir = .GlobalEnv)
}
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
alpha
proposal_sigs
varname
Nz=dim(Xdata$Xs)[1]
varname_list=c('lambda','beta_mat_f','beta_mat_b')
proposal_sigs=list('lambda'=.1,'beta_mat_f'=.1,'beta_mat_b'=.1)
sum_funs=list('lambda'=identity)
if(is.null(init_vals)){
init_vals=gen_initial_values_longitudinal(Xdata,Q)
}
current_values=init_vals
# M=configfile$M
store_iter=1
batch_size=1000
q_info=generate_q_info(Q)
acceptance_rates=lapply(varname_list,function(x) rep(NA,M))
names(acceptance_rates)=varname_list
update_sigma_tf=lapply(varname_list,function(x) FALSE)
names(update_sigma_tf)=varname_list
stored_parameters=list(current_values)
start_index=1
nsteps=1
for(jj in start_index:M)
{
if(jj%%10==0 & verb){
print(jj)
}
store=jj%%store_iter==0
storej=floor(jj/store_iter)
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
}
assign("proposal_sigs",proposal_sigs,envir = .GlobalEnv)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1){
proposal_sigs[[varname]]=1
}
}
}
current_values=init_vals
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=mcmc_values
varname
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
init_vals=gen_initial_values_longitudinal(Xdata,Q)
init_vals$beta_mat_f
current_values=init_vals
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
out$newvalue$beta_mat_f
out$newvalue$beta_mat_b
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
}
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
}
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
}
assign("proposal_sigs",proposal_sigs,envir = .GlobalEnv)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1){
proposal_sigs[[varname]]=1
}
}
proposal_sigs
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
}
assign("proposal_sigs",proposal_sigs,envir = .GlobalEnv)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1){
proposal_sigs[[varname]]=1
}
}
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1 | is.na(proposal_sigs)){
proposal_sigs[[varname]]=1
}
}
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1 | is.na(proposal_sigs[[varname]])){
proposal_sigs[[varname]]=1
}
}
for(jj in start_index:M)
{
if(jj%%10==0 & verb){
print(jj)
}
store=jj%%store_iter==0
storej=floor(jj/store_iter)
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
}
assign("proposal_sigs",proposal_sigs,envir = .GlobalEnv)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1 | is.na(proposal_sigs[[varname]])){
proposal_sigs[[varname]]=1
}
}
}
current_values$beta_mat_f
current_values$beta_mat_b
compute_transition_matrix(mcmc_values,Xdata=Xdata,q_info)
last_parameter=stored_parameters[[length(stored_parameters)]]
run_mcmc_sampler_longitudinal(last_parameter)
last_parameter=current_values
run_mcmc_sampler_longitudinal(last_parameter)
# mcmc_values=gen_initial_values_longitudinal(Xdata,Q)
# compute_transition_matrix(mcmc_values,Xdata=Xdata,q_info)
mcmc_out=run_mcmc_sampler_longitudinal(Xdata,Q,1000)
run_mcmc_sampler_longitudinal<-function(Xdata,Q,M,configlist=NULL,init_vals=NULL,verb=T){
Nz=dim(Xdata$Xs)[1]
varname_list=c('lambda','beta_mat_f','beta_mat_b')
proposal_sigs=list('lambda'=.1,'beta_mat_f'=.1,'beta_mat_b'=.1)
sum_funs=list('lambda'=identity)
if(is.null(init_vals)){
init_vals=gen_initial_values_longitudinal(Xdata,Q)
}
current_values=init_vals
# M=configfile$M
store_iter=1
batch_size=1000
q_info=generate_q_info(Q)
acceptance_rates=lapply(varname_list,function(x) rep(NA,M))
names(acceptance_rates)=varname_list
update_sigma_tf=lapply(varname_list,function(x) FALSE)
names(update_sigma_tf)=varname_list
stored_parameters=list(current_values)
start_index=1
nsteps=1
for(jj in start_index:M)
{
if(jj%%10==0 & verb){
print(jj)
}
store=jj%%store_iter==0
storej=floor(jj/store_iter)
for(varname in c('lambda','beta_mat_f','beta_mat_b')){
acceptance_rates[[varname]][jj]=0
out=update_var_generic(current_values,Xdata,q_info,proposal_sigs,likfun=likelihood_longitudinal,varname=varname)
current_values=out$newvalue
acceptance_rates[[varname]][jj]=acceptance_rates[[varname]][jj]+(out$accepts)/nsteps
stored_parameters[[storej]]=current_values
mi=max(1,jj-batch_size)
}
assign("proposal_sigs",proposal_sigs,envir = .GlobalEnv)
for(varname in varname_list)
{
#rosenthall and roberts algorithm
delta=ifelse(mean(acceptance_rates[[varname]][batch_size:jj],na.rm=T)>.44,
min(.01,1/sqrt(jj)),-min(.01,1/sqrt(jj)))
proposal_sigs[[varname]]=proposal_sigs[[varname]]*exp(delta)
if(proposal_sigs[[varname]]>1 | is.na(proposal_sigs[[varname]])){
proposal_sigs[[varname]]=1
}
}
}
return(stored_parameters)
}
# mcmc_values=gen_initial_values_longitudinal(Xdata,Q)
# compute_transition_matrix(mcmc_values,Xdata=Xdata,q_info)
mcmc_out=run_mcmc_sampler_longitudinal(Xdata,Q,1000)
compute_transition_matrix(last_parameter,Xdata,q_info)
compute_transition_matrix(last_parameter,Xdata,q_info)[,1]
compute_transition_matrix(last_parameter,Xdata,q_info)[1,,]
compute_transition_matrix(last_parameter,Xdata,q_info)[,,1]
compute_transition_matrix
Xdata
Xtest=list(design_mat=matrix(c(1,0),2,1))
compute_transition_matrix(mcmc_values,Xdata=Xtest,q_info)
Xtest$design_mat
Xtest=list(design_mat=matrix(c(1,0),1,2))
Xtest=list(design_mat=matrix(c(1,0),1,2))
compute_transition_matrix(mcmc_values,Xdata=Xtest,q_info)
compute_transition_matrix(last_parameter,Xdata,q_info)[,,1]
transmat=compute_transition_matrix(last_parameter,Xdata,q_info)[,,1]
q_info$skill_in_profile
rownames(transmat)=q_info$profile_list%>%{do.call(c,.)}
q_info$profile_list%>%{do.call(c,.)}
rownames(transmat)=q_info$profile_list%>%{do.call(rbind,.)}
rownames(transmat)=q_info$profile_list%>%{do.call(cbind,.)}
# rownames(transmat)=
q_info$profile_list%>%{do.call(cbind,.)}
# rownames(transmat)=
map_chr(q_info$profile_list,paste(collapse = ''))
# rownames(transmat)=
map_chr(q_info$profile_list,~paste(.,collapse = ''))
colnames(transmat)=  map_chr(q_info$profile_list,~paste(.,collapse = ''))
transmat
rownames(transmat)=  map_chr(q_info$profile_list,~paste(.,collapse = ''))
colnames(transmat)=  map_chr(q_info$profile_list,~paste(.,collapse = ''))
transmat
transmat=compute_transition_matrix(last_parameter,Xdata,q_info)[,,10]
rownames(transmat)=  map_chr(q_info$profile_list,~paste(.,collapse = ''))
colnames(transmat)=  map_chr(q_info$profile_list,~paste(.,collapse = ''))
transmat
transmat=compute_transition_matrix(mcmc_values,Xdata,q_info)[,,10]
rownames(transmat)=  map_chr(q_info$profile_list,~paste(.,collapse = ''))
colnames(transmat)=  map_chr(q_info$profile_list,~paste(.,collapse = ''))
transmat
xtable(transmat)
xtable::xtable(transmat)
xtable::xtable(transmat*100)
help(xtable)
paste0(transmat,'%')
paste0(round(transmat*100,1),'%')
paste0(round(transmat*100,1),'%')%>%matrix(.,dim(.)[1],dim(.)[2])
paste0(round(transmat*100,1),'%')%>%matrix(dim(.)[1],dim(.)[2])
paste0(round(transmat*100,1),'%')%>%matrix(dim(transmat)[1],dim(transmat)[2])
transmat=paste0(round(transmat*100,1),'%')%>%matrix(dim(transmat)[1],dim(transmat)[2])
xtable::xtable(transmat*100)
transmat=compute_transition_matrix(mcmc_values,Xdata,q_info)[,,10]
rownames(transmat)=  map_chr(q_info$profile_list,~paste(.,collapse = ''))
colnames(transmat)=  map_chr(q_info$profile_list,~paste(.,collapse = ''))
transmat_disp=paste0(round(transmat*100,1),'%')%>%matrix(dim(transmat)[1],dim(transmat)[2])
xtable::xtable(transmat)
round(transmat*100,1)
transmat_disp=paste0(round(transmat*100,1),'%')%>%matrix(dim(transmat)[1],dim(transmat)[2])
transmat_disp
xtable::xtable(transmat)
xtable::xtable(transmat_disp)
transmat_disp=paste0(round(transmat*100,1),'%')%>%matrix(dim(transmat)[1],dim(transmat)[2])
rownames(transmat_disp)=map_chr(q_info$profile_list,~paste(.,collapse = ''))
colnames(transmat_disp)=map_chr(q_info$profile_list,~paste(.,collapse = ''))
xtable::xtable(transmat_disp)
simout=simulated_cdm_data_longitudinal(Nskill=2,seed=123,Nresp_per_profile = 20)
Xdata=simout$Xdata
Q=simout$Q
true_attributes=simout$true_attributes
q_info=generate_q_info(Q)
# mcmc_values=gen_initial_values_longitudinal(Xdata,Q)
# compute_transition_matrix(mcmc_values,Xdata=Xdata,q_info)
mcmc_out=run_mcmc_sampler_longitudinal(Xdata,Q,1000)
last_parameter=mcmc_out[[length(mcmc_out)]]
transmat=compute_transition_matrix(mcmc_values,Xdata,q_info)[,,10]
transmat_disp=paste0(round(transmat*100,1),'%')%>%matrix(dim(transmat)[1],dim(transmat)[2])
rownames(transmat_disp)=map_chr(q_info$profile_list,~paste(.,collapse = ''))
colnames(transmat_disp)=map_chr(q_info$profile_list,~paste(.,collapse = ''))
xtable::xtable(transmat_disp)
last_parameter=mcmc_out[[length(mcmc_out)]]
transmat=compute_transition_matrix(last_parameter,Xdata,q_info)[,,10]
transmat_disp=paste0(round(transmat*100,1),'%')%>%matrix(dim(transmat)[1],dim(transmat)[2])
rownames(transmat_disp)=map_chr(q_info$profile_list,~paste(.,collapse = ''))
colnames(transmat_disp)=map_chr(q_info$profile_list,~paste(.,collapse = ''))
xtable::xtable(transmat_disp)
last_parameter$beta_mat_f
last_parameter$beta_mat_b
mcmc_values=gen_initial_values_longitudinal(Xdata,Q)
mcmc_values$beta_mat_f
mcmc_values$beta_mat_b
Xdata$design_mat
transmat=compute_transition_matrix(last_parameter,Xdata,q_info)[,,80]
transmat_disp=paste0(round(transmat*100,1),'%')%>%matrix(dim(transmat)[1],dim(transmat)[2])
rownames(transmat_disp)=map_chr(q_info$profile_list,~paste(.,collapse = ''))
colnames(transmat_disp)=map_chr(q_info$profile_list,~paste(.,collapse = ''))
xtable::xtable(transmat_disp)
# devtools::load_all(".")
require(cdmfits)
# devtools::load_all(".")
require(cdmfits)
require(tidyverse)
simout=simulated_cdm_data(Nskill=3,seed=123,Nresp_per_profile = 20)
X=simout$X
Q=simout$Q
true_attributes=simout$true_attributes
model_names=c('mcmc_cdmfits',
'variational',
'em_cdmfits',
'variational_em_cdmfits',
'mcmc_stan',
'gdina_CDM')%>%set_names(.,.)
fit_info=data.frame(name=model_names,
t=NA,accuracy=NA)
