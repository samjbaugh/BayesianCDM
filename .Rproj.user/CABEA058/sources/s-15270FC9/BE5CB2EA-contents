generate_logits_discrete<-function(params,q_info){
  Nquestions=params$Ns$Nquestions
  Nskill=params$Ns$Nskill
  Nprofile=params$Ns$Nprofile
  value_key=params$value_key

  intercepts=params$theta[value_key=='intercepts']
  base_effects=matrix(params$theta[value_key=='base_effects'],Nquestions,Nskill)
  interactions=params$theta[value_key=='interactions']

  Ninteraction=length(interactions)

  ret_logits=matrix(0,Nq,Nprofile)
  for(iquestion in 1:Nq){
    for(iprofile in 1:Nprofile){
      myprob =
        intercepts[iquestion];
      for(iskill in 1:Nskill){
        if(q_info$Q[iquestion,iskill]==1 &
           q_info$skill_in_profile[iskill,iprofile]==1){
          myprob=myprob +
            base_effects[iquestion,iskill];
        }
      }
      for(i_interaction in 1:Ninteraction){
        if(q_info$interaction_qids[i_interaction]==iquestion &
           q_info$interaction_in_profile[i_interaction,iprofile]==1){
          myprob=myprob + interactions[i_interaction];
        }
      }
      ret_logits[iquestion,iprofile]=myprob
    }
  }

  return(ret_logits)
}


#' Generates logit probabilities for each person/question
#'
#' @description This function assumes an additive logit model where
#' each question has an intercept, a base effect corresponding to
#' each skill in its Q-matrix, and an interaction effect for every
#' n-tuple of skills specified by its Q-matrix.
#' @param intercepts Intercept effects for each question
#' @param base_effects Base effects for each question/required skill
#' pair
#' @param interactions Interaction effects for each question/required
#' skill interaction pair
#' @param q_info Output of generate_q_info(Q)
#' @param Nz Number of respondents
#' @param get_liks Should likelihoods be returned?
#' @param X Response matrix to use if get_liks=T
#' @import stats
#' @return Returns logit probabilities
#' @export
generate_logit_probabilities_old<-function(intercepts,base_effects,
                                       interactions,q_info,
                                       X=NA,Nz=NA){
  Nq=dim(base_effects)[1]
  Nskill=dim(q_info$Q)[2]
  Nprofile=2^Nskill

  Ninteraction=length(interactions)

  ret_logits=matrix(0,Nq,Nprofile)
  for(iquestion in 1:Nq){
    for(iprofile in 1:Nprofile){
      myprob =
        intercepts[iquestion];
      for(iskill in 1:Nskill){
        if(q_info$Q[iquestion,iskill]==1 &
           q_info$skill_in_profile[iskill,iprofile]==1){
          myprob =myprob +
            base_effects[iquestion,iskill];
        }
      }
      for(i_interaction in 1:Ninteraction){
        if(q_info$interaction_qids[i_interaction]==iquestion &
           q_info$interaction_in_profile[i_interaction,iprofile]==1){
          myprob = myprob +
            interactions[i_interaction];
        }
      }
      ret_logits[iquestion,iprofile]=myprob
    }
  }


  return(list('logits'=ret_logits))
}

generate_logit_probabilities_continuous<-function(params,q_info,
                                       continuous_effects,
                                       X=NA,Nz=NA){


  intercepts=
  base_effects=
  interactions=

  Nq=dim(base_effects)[1]
  Nskill=dim(q_info$Q)[2]
  Nprofile=2^Nskill

  Ninteraction=length(interactions)

  ret_logits=matrix(0,Nq,Nprofile)
  for(iquestion in 1:Nq){
    for(iprofile in 1:Nprofile){
      myprob =
        intercepts[iquestion];
      for(iskill in 1:Nskill){
        if(q_info$Q[iquestion,iskill]==1 &
           q_info$skill_in_profile[iskill,iprofile]==1){
          myprob=myprob +
            base_effects[iquestion,iskill];
        }
      }
      for(i_interaction in 1:Ninteraction){
        if(q_info$interaction_qids[i_interaction]==iquestion &
           q_info$interaction_in_profile[i_interaction,iprofile]==1){
          myprob = myprob +
            interactions[i_interaction];
        }
      }
      ret_logits[iquestion,iprofile]=myprob
    }
  }


  return(list('logits'=ret_logits))
}

#' Wrapper fun
#'
#' @param myvalues Values
#' @return Returns logit probs
#' @export
logit_probs_from_vals<-function(myvalues,q_info,continuous){
  value_key=myvalues$value_key
  Nq=dim(q_info$Q)[1]
  Nskill=dim(q_info$Q)[2]
  retval=generate_logit_probabilities_discrete(
    intercepts=myvalues$lambda[value_key=='intercepts'],
    base_effects=matrix(myvalues$lambda[value_key=='base_effects'],Nq,Nskill),
    interactions=myvalues$lambda[value_key=='interactions'],
    q_info=q_info)$logits
  return(retval)
}



#' Probs to liks
#'
#' @param model_logits model_logits
#' @param X item-response matrix
#' @return Return liks from probs
#' @export
liks_from_logits<-function(model_logits,X,q_info){
  Nz=dim(X)[1]
  Nq=dim(X)[2]
  Nprofile=dim(model_logits)[2]

  all_liks=array(NA,c(Nz,Nq,Nprofile))
  for(iperson in 1:Nz){
    for(iquestion in 1:Nq){
      for(iprofile in 1:Nprofile){
        all_liks[iperson,iquestion,iprofile]=stats::dbinom(X[iperson,iquestion],1,
                                                           logit(model_logits[iquestion,iprofile]),log=T)
      }
    }
  }
  return(all_liks)
}

#' predicted profiles from likelihoods
#'
#' @param liks
#' @export
pred_prof_from_liks<-function(liks){
  return(apply(liks,1,function(x) {y=apply(x,2,sum);  which(y==max(y))}))
}

#' stan out to preds
#'
#' @param
#' @export
variational_out_to_preds<-function(stan_out,Q){
  q_info=generate_q_info(Q)
  a1=generate_logit_probabilities(
    apply(stan_out$intercepts,2,mean),
    apply(stan_out$base_effects,c(2,3),mean),
    apply(stan_out$intercepts,2,mean),
    q_info)
  a2=liks_from_logits(a1$logits,X,q_info)
  a3=pred_prof_from_liks(a2)
  return(a3)
}

#'
#' @param vals
#' @export
vals_to_preds<-function(vals,Q){
  q_info=generate_q_info(Q)
  logits=logit_probs_from_vals(vals,q_info)
  liks=liks_from_logits(logits,X,q_info)
  preds=pred_prof_from_liks(liks)
  return(preds)
}

extract_a<-function(vals,Q){
  q_info=generate_q_info(Q)
  logits=logit_probs_from_vals(vals,q_info)
  liks=liks_from_logits(logits,X,q_info)
  as=apply(liks,1,function(x) {y=apply(x,2,sum)})
  return(exp(as))
}
